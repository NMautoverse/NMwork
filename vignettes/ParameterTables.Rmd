---
title: "NMwork - Create Nonmem Parameter Tables"
author: 
  - name: "Philip Delff"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
toctitle: "Contents"
output:
    html_document:
      toc: true
      toc_depth: 4
      toc_float: true
      number_sections: false
      df_print: kable
      editor_options:
        chunk_output_type: inline
      code_folding: show
pkgdown:
  as_is: true
---


```{css echo=FALSE}

body{
	font-size: 12pt;
}

h1.title {
	font-size: 24px;
	color: DarkRed;
	margin-top: 2em;
	margin-bottom: 1em;
}
h1 { /* Header 1 */
	font-size: 20px;
	color: DarkBlue;
}
h2 { /* Header 2 */
	margin-top: 1em;
	font-size: 20px;
	color: DarkBlue;
}
h3 { /* Header 3 */
	font-size: 18px;
	font-family: "Times New Roman", Times, serif;
	color: DarkBlue;
}
h4 { /* Header 4 */
	font-size: 16px;
	font-family: "Times New Roman", Times, serif;
	color: DarkBlue;
}
table.Rtable1 {
    font-size: 12px;
}

.superbigimage{
    overflow-x:scroll;
    white-space: nowrap;
}

.superbigimage img{
    max-width: none;
}

h4.author {
	font-weight:bold;
	font-style:italic;
	margin-top: 0em;
	margin-bottom: 1em;
}
h4.date {
	font-weight:bold;
	margin-top: 0em;
	margin-bottom: 5em;
}


/* -----------div tips------------- */

div.summary {
	padding: 1em;
	margin: 1em;
	padding-left: 50px;
	background-size: 30px;
	background-repeat: no-repeat;
	background-position: 10px 10px;
	min-height: 40px;
	font-size: 16px;
	color: #000000;
	background-color: #bed3ec;
	border: solid 5px #dfedff;
	/* background-image: url("Summary_ffffff.png"); */
}

div.data {
	padding: 1em;
	margin: 1em;
	padding-left: 50px;
	background-size: 30px;
	background-repeat: no-repeat;
	background-position: 10px 10px;
	min-height: 40px;
	font-size: 16px;
	color: #000000;
	background-color: #FAD07D;
	border: solid 5px #FFDE9C;
	/* background-image: url("Stats graph_ffffff.png"); */
}


/* ----------- code fold button ------------- */
.showopt {
	display:inline-block;
	width: 120px;
	height: 29px;
	text-align: center;
	font-weight:400;
	vertical-align: middle !important;
	float: right;
	font-family: sans-serif;
	border-radius: 8px;
	cursor: pointer;
	border-color: #adb1b8 #a2a6ac #8d9096;
	border-style: solid;
	box-shadow: rgba(255,255,255,.6) 0 1px 0 inset;
	background-image:none;
}

pre{
	width:100%;
}

```



```{r, setup, include=FALSE}
## install pmtables
                                        # mpn <- "https://mpn.metworx.com/snapshots/stable/2025-11-24"
                                        # install.packages("pmtables", repos = mpn)

knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      tidy = FALSE,
                      message = FALSE,
                      fig.align = 'center',
                      out.width = "100%"
                     ,fig.height=3.7
                      )

knitr::opts_hooks$set(function(options) {
    if (is.null(options$fig.alt) && !is.null(options$fig.cap)) {
        options$fig.alt <- options$fig.cap
    }
    options
})

options(knitr.table.format = "html") 

library(data.table)
library(knitr)
library(kableExtra)
library(NMdata)
library(NMsim)

# library(devtools)
# load_all("~/wdirs/NMwork")
library(NMwork)

## Get the setup ready for NMsim
path.candidates <- c(## metworx
    "/opt/NONMEM/nm75/run/nmfe75"
    ## custom linux
   ,"/opt/nonmem/nm751/run/nmfe75"
    ## Ahmed
   ,"c:/nm75g64/run/nmfe75.bat"
)
NMdataConf(path.nonmem = NMsim:::prioritizePaths(path.candidates)) ## path to whichever NONM

NMdataConf(##path.nonmem = "/opt/NONMEM/nm75/run/nmfe75"
    ## path.nonmem = "/opt/nonmem/nm751/run/nmfe75"
    ## ,dir.sims="~/NMsim_vignette/simtmp/simtmp-intro"
    dir.sims="simtmp-intro"
   ,dir.res="simres-intro"
   ,as.fun="data.table"
)

library(ggplot2)
## theme_set(theme_bw()+theme(legend.position="bottom",strip.background =element_rect(fill="white")))
theme_set(theme_classic()+theme(legend.position="bottom",strip.background = element_blank()))
##scale_color_manual(values=c("orange","blue","darkgreen"))
options(ggplot2.discrete.colour=c("orange","blue","darkgreen"))
options(ggplot2.discrete.fill=c("orange","blue","darkgreen"))

set.seed(11112024)

reuse.results <- TRUE
```

# Objectives

- Create parameter tables, using annotation of control stream parameter sections 

- Print parameter tables to various formats (R console, jpg, word, ppt, pdf, include in Rmd document)

- Modify subsets of information provided in parameter section annotations 

- Use flexible tools to generate information when parameter sections are less diligently annotated

# Introduction

A table of model parameter estimates is some of the most basic model
information. Nevertheless, it is often cumbersome to get a decently
annotated table of parameter estimates. In Nonmem control streams, the
definition of parameters such as \theta's, \Omega's and \Sigma's is
handled in `$THETA`, `$OMEGA` and `$SIGMA` while the definition of
variables such as `CL` or `KIN` is handled elsewhere, typically in
`$PK`, `$PRED` or `$ERROR`. This allows for flexibility in model
definition but it also leaves some book keeping to the user for
interpretation of the parameter estimates. One can choose to avoid
interpretation of parameters by outputting the variables themselves in
`$TABLE`. That way, they can simulate out the (often) more easily
interpretable variable values without relying on translation between
parameters and variables. However, by interpreting the parameter
values (preferably including appropriate transformation to
physiological variables), one can make direct use of other properties
estimated by Nonmem such as parameter precision as estimated in the
$COVARIANCE step. This vignette presents a flexible and easy-to-use
framework for handling this bookkeeping, with the benefit of automated
generation of annotated parameter tables.


Let's break the generation of parameter tables into four steps. 

1. Annotation of control streams (down to the user)

2. Compilation of annotations, parameter estimates and precision, if present (tools available in `NMdata`)

3. Formatting of parameter table information (`NMwork::createParameterTable`)

4. Printing of parameter table information (`NMwork::printParameterTable`)


Provided that step 1. is done informatively, step 2 is fully wrapped into step 3. This means, you can end up with as simple a workflow as this


```{r,eval=FALSE,results="asis",include=FALSE}
load_all ()
file.mod <- system.file("nonmem/xgxr134.mod",package="NMwork")
partab <- createParameterTable(file.mod)
printParameterTable(partab,format="R")
```

```{r,eval=FALSE,include=FALSE}
printParameterTable(partab,engine="flextable") |>
    save_as_image(path="partab1.png")
library(knitr)
include_graphics("partab1.png")
```

<!-- Because of bug in NMdata 0.2.2 we need to supply formats here -->
```{r,eval=TRUE,echo=FALSE}
file.mod <- system.file("nonmem/xgxr134.mod",package="NMwork")
partab <- createParameterTable(file.mod,args.ParsText=list(format.sigma="%symbol - %label ; %trans"))
printParameterTable(partab,format="html") 
```


```{r,eval=FALSE,echo=TRUE}
file.mod <- system.file("nonmem/xgxr134.mod",package="NMwork")
partab <- createParameterTable(file.mod)
printParameterTable(partab,format="html") 
```



In the rest of this document, we will see what all this did, how you
can get it to work, and how you can fill in the information if this
was not done during model development (the annotation in step 1
above).


While `createParameterTable()` and `printParameterTable()` are offered
by `NMwork`, the underlying functionality is largely provided by
`NMdata`. For the best experience, make sure to keep NMdata up to date
from CRAN.

## When to Use This
The methods shown in this document are intended to automate generation 
of publication-ready parameter estimate tables. Because of the
informative value of such tables and because they are easy to generate
(especially with a few simple habits of how to document parameter
interpretation in control streams), the recommendation is to use them
during model development as well as for reporting. However, the solutions provided by `createParameterTables()` and `printParameterTables()` are not very flexible in terms of the final output. While the underlying functions provided in `NMdata` to retrieve and compile the data are intended to work as generally as possible, `NMwork` includes many decisions related to formatting etc. The user may not agree with all this, and in that case they may need to edit the code to get their prefered behavior.

# Creating the Parameter Table (`createParameterTable()`)

## Formatting Features

`createParameterTable()` uses the following columns to format the parameter
table. Hence, large parts of this document describes techniques to fill in the
columns of interest to `createParameterTable()`. These are (all characters):

- `symbol`: Typically, the variable name associated with the parameter, e.g. "CL".
- `label`: The parameter label, e.g. "Clearance".
- `trans`: Parameter transformation (character strings). 
- `unit`: The parameter unit, e.g. "L/h".
- `panel`: Grouping variable. Can be an intermediary short-hand code like
"struct" or "iiv". 

`createParameterTable()` will use those columns for formatting, if
available. Sensible default values are being used where possible. If no `symbol`
column is available, the parameter name (i.e. `THETA(1)`) will be used. The
default parameter description is "label, symbol (unit)" (unit) If `label` and/or
`unit` are missing, the resulting parameter description will just omit them.



## Example 1: Annotation of Control Stream Parameter Sections
This approach is the simplest to show because it is what we already
did in the introduction. All the preparations are done in the control
stream, and `createParamaterTable()` can do the rest of the work.


Take a look at the parameter sections of the control stream of the model we just read for the parameter table above. 
<!-- show how the annotation is done in the control stream -->

```{r,echo=FALSE,comment=""}
printParSections <- function(file.mod){
    all.lines <- as.NMctl(file.mod)
    c(all.lines[grepl("format:",all.lines)],
      NMdata::as.NMctl(
                  NMreadSection(file.mod,section="THETA"),
                  lines=TRUE
              ),

      all.lines[grepl("format\\.omega:",all.lines)],
      NMdata::as.NMctl(
                  NMreadSection(file.mod,section="OMEGA"),
                  lines=TRUE
              ),

      ##all.lines[grepl("format\\.sigma:",all.lines)],
      NMdata::as.NMctl(
                  NMreadSection(file.mod,section="SIGMA"),
                  lines=TRUE
              )


      ) |> cat(sep="\n")
    return(invisible(NULL))
}

printParSections(file.mod)
```

Each `$THETA`  definition is annotated with descriptive information such as the
variable "symbol" (TVKA), label (Absorption rate), unit (1/h), and
transformation (log). I know I skipped the `idx` column too, but that is
intentional. While such a counter can be very useful during model development,
`createParameterTable()` does not need it. 

Notice a few things about the format
- The format of the annotations is up to the user as long as it is
consistent within parmeter types (i.e. all `$THETA`s annotations
must be consistent).
- Delimiters can vary. between idx and symbol, a colon (:) is used,
between symbol and label it a semicolon, and the unit is in
brackets. The latter acrually means the at the delimitor between
label and unit is a left bracket ([), while the delimitor between
unit and trans is a composite of a right bracket and a semicolon
(];). Spaces surrounding delimiters are dropped, so "] ;", "] ;" and
"];" all mean the same. By the way, tabulator characters are treated
like spaces.
- As a note of how the parameters have been documented, the modeler
has left a comment string starting with "format:" where the column
names in the desired table have been labeled with %-signs. In fact,
that's what `createParameterTable()` used to learn how to generate the
table. 
- The `$OMEGA` annotations only contain `idx` and `symbol`. In this
case all the `ETA`s are used for log-normal distributed
between-subject variability so a diligent annotation of these
parameters are redundant. Since the formatting of `idx` and `symbol`
(and of course the delimiter between them) are consistent with the
`$THETA` annotations. The missing fields, `label`, `unit` and
`trans` will be filled with `NA`s.
- The `$SIGMA` parameters are annotated differently. The annotation columns are `symbol`, `label`, and `trans`, but the delimiters are different, and `unit` is not included. 
- The annotation scheme used for `$SIGMA`s is documented in a comment
starting with `format.sigma:`. `createParameterTable()` finds this
automatically.

`createParameterTable()` collects 

```{r createParTab-res}
head(partab,2)
```


## Example: Specify Formats
If you have a control stream with consistent annotation but without
the "`format`" lines to document the annotation format in the control
stream, you can include that format in `createParameterTables()` using
the `args.ParsText` argument.

```{r args.ParsText,eval=FALSE}
createParameterTable(file.lst=file.mod,args.ParsText=list(format="%idx - %symbol - %unit",format.omega="%idx-%symbol"))
```

The reason for the argument name `args.ParsText` is that that all you
provide will be passed to `NMdata::NMreadParsText()` which is what
`createParameterTable()` uses to process the control stream. If
formats are passed here, they overrule what may be defined in the
control stream.


## Example: Specify Selected Annotation Values
What we have seen so far relies on the modeler to diligently annotate all
parameters, and all text in the parameter table is coming directly from the
control stream. However, it may be desired to edit some of the
information. `createParameterTable()` has the arguments `df.repair` and
`by.repair` to do this. `createParameterTable()` uses `NMdata::mergeCoal()` to
do this. The basic idea is that non-`NA` values in `df.repair` are inserted into
(overwriting) the parameter table by matching the columns provided in
`by.repair`. `by.repair` is like `by` in merges, but `mergeCoal()` prioritizes
`df.repair` over the parameter annotations in the control stream.


```{r df.repair}
df.repair <- data.frame(symbol="WEIGHTCL",label="Bodyweight effect on clearance")
partab <- createParameterTable(file.mod,df.repair=df.repair,by.repair="symbol") |>
    printParameterTable(format="html")
```

`by.repair` can be a character vector of any length. But the main limitation of
this approach is that you can only use one `by.repair` vector. This means you
need one variable (say `symbol`) to be consistently read from the control
stream. You could merge by `parameter` (like `THETA1`, `OMEGA(1,1)` etc.) but
that breaks the benefit of linking parameters to variables in the control
stream.

## Example: Construct Annotations First 
Sometimes you may need to edit the table in more detail that what `df.repair`
and `by.repair` allow for. `createParameterTable()` offers the argument
`df.labs` for the user to completely format the labels prior to the table
generation. This allows for say multiple steps of `mergeCoal` or other manual
editing, or whatever automated techniques the user may have.

```{r manual-steps}
dt.labs <- NMreadParsText(file.mod)
df.repair <- data.frame(symbol="WEIGHTCL",label="Bodyweight effect on clearance")
dt.labs <- NMwork:::mergeCoal(dt.labs,df.repair,by="symbol",as.fun="data.table")
dt.labs[par.type=="OMEGA",label:=paste("IIV:",label)]
createParameterTable(file.mod,df.labs=dt.labs) |>
    printParameterTable(format="html")
```

A function to consider for automated detection of relationship between
parameters and Nonmem variables (like what is called `symbol` above) is
`NMdata::NMrelate()`.

```{r NMrelate}
NMrelate(file.mod)
```

`NMrelate()` looks at the control stream to identify variable assignments, shown
in the `code` column. The `label` column is an attempt to identify the name of
the variable the parameter is associated with. This works very well with some
limitations. For instance, `THETA`s will normally not work with \mu referencing because a `MU`
will be defined based on the parameter, which is no more informative than the
parameter name itself. Also, the control stream does not need to create named variables
at all and could use parameters like `THETA` and `ETA` directly in `$DES`. On
the other hand, by always creating named variables, you could automate this step
using `NMrelate()`.

For example, if the `$OMEGA`'s are not annotated, we can use `NMrelate` to fill
these in. The parameter sections in this model look like this:

```{r,echo=FALSE,comment=""}
file.mod.b <- system.file("nonmem/xgxr134b.mod",package="NMwork")
printParSections(file.mod.b)
```

```{r use-NMrelate-etas}
df.labs.b <- NMreadParsText(file.mod.b)[par.type!="OMEGA"] |>
    rbind(setnames(NMrelate(file.mod.b)[par.type=="OMEGA"],"label","symbol"),fill=TRUE)
```

Now we filled in the `symbol` column for the `$OMEGA` parameters so
`createParameterTable()` can label the parameters.
```{r df.labs-NMrelate}
df.labs.b[,.(par.type,par.name,symbol,label,unit,trans)]
```

And the parameter table becomes
```{r print-tab-NMrelate}
createParameterTable(file.lst=file.mod.b,df.labs=df.labs.b) |>
    printParameterTable(format="html")
```


# Printing the Parameter Table (`printParameterTable()`)
`printParameterTable()` prints the output from `createParameterTable()` using
predefined templates. Currently, it has two templates, of which the first is
designed for display in the R console, i.e. intended for interactive use. The
other is intended for reporting with all information explicitly expressed. 

`printParameterTable()` supports use of three "engines" to write tables:
`kable`, `pmtables`, and `flextable`. Switch between those using the `engine`
argument. The `format` argument specifies whether pdf, html


```{r print-formats,echo=FALSE}
dt <- rbind(data.table(engine="kable, pmtables",
                       format=cc(latex,file.pdf,pdf),
                       Description=c("latex code. Use in .tex/.Rmd or similar files.",
                                     "A path to a standalone pdf file to be generated. Absolute paths may not be supported with pmtables engine.",
                                     "A standalone pdf file in a temporary location, intended for interactive use.")),

            data.table(engine="kable",
                       format=cc(R,html),
                       Description=c("A simplified format printed in the R console. For interactive use.",
                                     "html code. To be used in html documents")),
            data.table(engine="flextable"
                       ##,format=cc(pptx,docx,html,png)
                       ),
            fill=TRUE
            )

kable(dt)

```

Currently, the `flextable` returns a flextable object which the user can save to
png, docx, pptx, etc. 

## Example: Include in Rmd report
If `createParameterTables()` has not already been called during the analysis,
the code could be this simple. Notice, here we choose `engine="pmtables"` to use
pmtables. This is because pmtables works with footnotes even for large tables
spanning multiple pages.  Use `engine="kable"` to get kable in stead (or of
course `engine="flextable"` can be used too.

```{r include-rmd,eval=FALSE}
createParameterTable(file.mod) |> 
    printParameterTable(partab,format="latex", engine="pmtables") 
```

Depending on the model and the (missing) annotations of parameter definitions,
running `createParameterTable()` may take a little customization, as discussed
above. Therefore, it may be desired to load the result of that step, and then
run `printParameterTable()`. In that case

### If Paths Have Changed
`file.mod`

## Subsetting Parameters to Print
Notice not all parameters are printed above. The argument `include.fix` controls
whether to include fixed parameters. The options are  "notZero (default,
inclde only fixed variables different from zero), `TRUE` (include fixed
parameters) and `FALSE` (omit all fixed parameters). Also, see additional
arguments to control what parameters to include: `include`, `include.pattern`,
`drop`, `drop.pattern` in the manual.



## Title and Footnote Generation
`printParameterTable()` by default inserts a title with the model name. This can
be modified through the `caption` argument. Footnotes are also included.


## meta data
`script`
